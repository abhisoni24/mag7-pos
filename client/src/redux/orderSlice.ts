import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import * as api from "../lib/api";

/**
 * @interface OrderItem
 * @description Interface for an item within an order.
 * @param {string} menuItemId - The ID of the menu item.
 * @param {string} name - The name of the item.
 * @param {number} quantity - The quantity of the item in the order.
 * @param {number} price - The price of the item.
 * @param {string} notes - Any special notes for the item (optional).
 * @param {string} status - The status of the item (e.g., 'pending', 'preparing', 'served').
 */
export interface OrderItem {
  menuItemId: string;
  name: string;
  quantity: number;
  price: number;
  notes?: string;
  status: string;
}

/**
 * @interface Order
 * @description Interface for an order.
 * @param {string} _id - The unique identifier of the order (optional, as it's generated by the database).
 * @param {string} tableId - The ID of the table the order is associated with.
 * @param {string} waiterId - The ID of the waiter assigned to the order (optional).
 * @param {string} status - The status of the order (e.g., 'new', 'in_progress', 'done', 'paid').
 * @param {string} createdAt - The timestamp when the order was created.
 * @param {string} updatedAt - The timestamp when the order was last updated.
 * @param {OrderItem[]} items - An array of items in the order.
 */
export interface Order {
  _id?: string;
  tableId: string;
  waiterId?: string;
  status: string;
  createdAt: string;
  updatedAt: string;
  items: OrderItem[];
}

/**
 * @interface OrderState
 * @description Interface for the order state in the Redux store.
 * @param {Order[]} orders - An array of orders.
 * @param {Order | null} currentOrder - The currently selected order, or null if no order is selected.
 * @param {boolean} loading - Indicates whether the order data is currently being loaded.
 * @param {string | null} error - Any error message that occurred while loading the order data, or null if there was no error.
 */
interface OrderState {
  orders: Order[];
  currentOrder: Order | null;
  loading: boolean;
  error: string | null;
}

const initialState: OrderState = {
  orders: [],
  currentOrder: null,
  loading: false,
  error: null,
};

/**
 * @asyncThunk fetchOrders
 * @description Async thunk action to fetch orders from the server.
 * @param {Object} params - An object containing optional parameters to filter the orders.
 * @param {string} params.status - The status to filter orders by (optional).
 * @param {string} params.tableId - The table ID to filter orders by (optional).
 * @param {string} params.waiterId - The waiter ID to filter orders by (optional).
 * @returns {Promise<Order[]>} - A promise that resolves with an array of orders.
 */
export const fetchOrders = createAsyncThunk(
  "orders/fetchOrders",
  async (
    params: { status?: string; tableId?: string; waiterId?: string } = {},
    { rejectWithValue }
  ) => {
    try {
      const response = await api.getOrders(params);
      return response.orders;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to fetch orders");
    }
  }
);

/**
 * @asyncThunk getOrderById
 * @description Async thunk action to get a single order by its ID from the server.
 * @param {string} id - The ID of the order to fetch.
 * @returns {Promise<Order>} - A promise that resolves with the order.
 */
export const getOrderById = createAsyncThunk(
  "orders/getOrderById",
  async (id: string, { rejectWithValue }) => {
    try {
      const response = await api.getOrder(id);
      return response.order;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to fetch order");
    }
  }
);

/**
 * @asyncThunk createOrder
 * @description Async thunk action to create a new order on the server.
 * @param {Object} data - An object containing the data for the new order.
 * @param {string} data.tableId - The ID of the table the order is associated with.
 * @param {string} data.waiterId - The ID of the waiter assigned to the order (optional).
 * @param {any[]} data.items - An array of items in the order (optional).
 * @returns {Promise<Order>} - A promise that resolves with the newly created order.
 */
export const createOrder = createAsyncThunk(
  "orders/createOrder",
  async (
    data: { tableId: string; waiterId?: string; items?: any[] },
    { rejectWithValue }
  ) => {
    try {
      const response = await api.createOrder(data);
      return response.order;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to create order");
    }
  }
);

/**
 * @asyncThunk updateOrderStatus
 * @description Async thunk action to update the status of an order on the server.
 * @param {Object} params - An object containing the ID of the order and the new status.
 * @param {string} params.id - The ID of the order to update.
 * @param {string} params.status - The new status of the order.
 * @returns {Promise<Order>} - A promise that resolves with the updated order.
 */
export const updateOrderStatus = createAsyncThunk(
  "orders/updateOrderStatus",
  async (
    { id, status }: { id: string; status: string },
    { rejectWithValue }
  ) => {
    try {
      const response = await api.updateOrderStatus(id, status);
      return response.order;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to update order status");
    }
  }
);

/**
 * @asyncThunk addItemToOrder
 * @description Async thunk action to add an item to an existing order on the server.
 * @param {Object} params - An object containing the ID of the order and the item to add.
 * @param {string} params.orderId - The ID of the order to add the item to.
 * @param {any} params.item - The item to add to the order.
 * @returns {Promise<Order>} - A promise that resolves with the updated order.
 */
export const addItemToOrder = createAsyncThunk(
  "orders/addItemToOrder",
  async (
    { orderId, item }: { orderId: string; item: any },
    { rejectWithValue }
  ) => {
    try {
      const response = await api.addItemToOrder(orderId, item);
      return response.order;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to add item to order");
    }
  }
);

/**
 * @asyncThunk updateOrderItem
 * @description Async thunk action to update an item in an existing order on the server.
 * @param {Object} params - An object containing the IDs of the order and item to update, and the updates to apply.
 * @param {string} params.orderId - The ID of the order containing the item to update.
 * @param {string} params.itemId - The ID of the item to update.
 * @param {any} params.updates - The updates to apply to the item.
 * @returns {Promise<Order>} - A promise that resolves with the updated order.
 */
export const updateOrderItem = createAsyncThunk(
  "orders/updateOrderItem",
  async (
    {
      orderId,
      itemId,
      updates,
    }: { orderId: string; itemId: string; updates: any },
    { rejectWithValue }
  ) => {
    try {
      const response = await api.updateOrderItem(orderId, itemId, updates);
      return response.order;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to update order item");
    }
  }
);

/**
 * @asyncThunk createPayment
 * @description Async thunk action to create a payment for an order.
 * @param {Object} data - An object containing the payment details.
 * @param {string} data.orderId - The ID of the order to create the payment for.
 * @param {number} data.amount - The amount of the payment.
 * @param {number} data.tip - The tip amount (optional).
 * @param {string} data.paymentMethod - The payment method used.
 * @returns {Promise<any>} - A promise that resolves with the payment information.
 */
export const createPayment = createAsyncThunk(
  "orders/createPayment",
  async (
    data: {
      orderId: string;
      amount: number;
      tip?: number;
      paymentMethod: string;
    },
    { rejectWithValue }
  ) => {
    try {
      const response = await api.createPayment(data);
      return response.payment;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to process payment");
    }
  }
);

/**
 * @slice orderSlice
 * @description Redux slice for managing orders.
 */
const orderSlice = createSlice({
  name: "orders",
  initialState,
  reducers: {
    /**
     * @reducer setCurrentOrder
     * @description Reducer to set the current order.
     * @param {OrderState} state - The current order state.
     * @param {PayloadAction<Order | null>} action - The action containing the order to set as current.
     */
    setCurrentOrder: (state, action: PayloadAction<Order | null>) => {
      state.currentOrder = action.payload;
    },
    /**
     * @reducer clearCurrentOrder
     * @description Reducer to clear the current order.
     * @param {OrderState} state - The current order state.
     */
    clearCurrentOrder: (state) => {
      state.currentOrder = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchOrders.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(
        fetchOrders.fulfilled,
        (state, action: PayloadAction<Order[]>) => {
          state.loading = false;

          // Add new orders while ensuring no duplicates
          const newOrders = action.payload;
          const existingOrderIds = new Set(
            state.orders.map((order) => order._id)
          );

          // First remove any updated orders from state that exist in the new batch
          state.orders = state.orders.filter(
            (order) => !newOrders.some((newOrder) => newOrder._id === order._id)
          );

          // Then add all the new orders
          state.orders = [...state.orders, ...newOrders];
        }
      )
      .addCase(fetchOrders.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(getOrderById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(
        getOrderById.fulfilled,
        (state, action: PayloadAction<Order>) => {
          state.loading = false;
          state.currentOrder = action.payload;
        }
      )
      .addCase(getOrderById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(createOrder.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createOrder.fulfilled, (state, action: PayloadAction<Order>) => {
        state.loading = false;
        state.orders.push(action.payload);
        state.currentOrder = action.payload;
      })
      .addCase(createOrder.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(updateOrderStatus.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(
        updateOrderStatus.fulfilled,
        (state, action: PayloadAction<Order>) => {
          state.loading = false;
          state.orders = state.orders.map((order) =>
            order._id === action.payload._id ? action.payload : order
          );
          if (
            state.currentOrder &&
            state.currentOrder._id === action.payload._id
          ) {
            state.currentOrder = action.payload;
          }
        }
      )
      .addCase(updateOrderStatus.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(addItemToOrder.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(
        addItemToOrder.fulfilled,
        (state, action: PayloadAction<Order>) => {
          state.loading = false;
          state.orders = state.orders.map((order) =>
            order._id === action.payload._id ? action.payload : order
          );
          if (
            state.currentOrder &&
            state.currentOrder._id === action.payload._id
          ) {
            state.currentOrder = action.payload;
          }
        }
      )
      .addCase(addItemToOrder.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(updateOrderItem.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(
        updateOrderItem.fulfilled,
        (state, action: PayloadAction<Order>) => {
          state.loading = false;
          state.orders = state.orders.map((order) =>
            order._id === action.payload._id ? action.payload : order
          );
          if (
            state.currentOrder &&
            state.currentOrder._id === action.payload._id
          ) {
            state.currentOrder = action.payload;
          }
        }
      )
      .addCase(updateOrderItem.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(createPayment.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createPayment.fulfilled, (state) => {
        state.loading = false;
        // Refresh orders should be handled by fetchOrders
      })
      .addCase(createPayment.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export const { setCurrentOrder, clearCurrentOrder } = orderSlice.actions;
export default orderSlice.reducer;
